// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "@prisma/payments"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// /* PAYMENT METHODS */
model PaymentMethod {
  id              String   @id @default(uuid())
  provider        String?  // e.g., Visa, MasterCard, PayPal, Bank Transfer
  providerLogo    String?
  status          Status
  createdAt       DateTime @default(now())
  createdBy       String?
  updatedAt       DateTime @updatedAt
  deletedAt       DateTime?

  // relations
  payments    Payment[]
}

// to do: payments from proseeker to the application for things like kyc, featured, certification e.t.c

/* PAYMENTS */
model Payment {
  id                      String    @id @default(uuid())
  invoiceId               String @unique
  userId                  String
  paymentMethodId         String
  amount                  Decimal @db.Decimal(10, 2)
  amountCharged           Decimal @db.Decimal(10, 2)
  reference               String  // refernece to track this payment on the payment provider Id
  paymentAuthorization    Json?
  // to do - store more details about the payment from the provider
  currency                String    @default("USD")
  paymentReason           PaymentReason
  status                  PaymentStatus
  transactionId           String    @unique
  createdAt               DateTime  @default(now())
  updatedAt               DateTime      @updatedAt
  updatedBy               String?     
  deletedAt               DateTime?
  deletedBy               String?
  // relations
  refund                  Refund? 
  dispute                 Dispute?
  invoice                 Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade) 
  paymentMethod           PaymentMethod      @relation(fields: [paymentMethodId], references: [id], onDelete: Cascade)

}


/* INVOICES */
model Invoice {
  id                String    @id @default(uuid())
  reference         String @unique
  userId            String
  bookingId         String?
  subscriptionId    String?    // invoice is either for boooking or subscription
  items             Json[]
  amountDue         Decimal @db.Decimal(10, 2) // this is the actual amount to be paid 
  currency          String? @default("#")
  note              String?
  billingAddress    Json
  status            InvoiceStatus
  dueDate           DateTime
  createdAt         DateTime  @default(now())
  updatedAt         DateTime      @updatedAt
  deletedAt         DateTime?
  deletedBy         String?


  payments          Payment[] // an invoice can be paid twice in the case of payment errors
  subscription     Subscriptions? @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([bookingId])
  @@index([subscriptionId])
  @@index([status])
  @@index([currency])
}


/* REFUNDS */
model Refund {
  id             String    @id @default(uuid())
  paymentId      String     @unique
  amount         Float
  reason         String
  status         RefundStatus
  createdAt      DateTime  @default(now())
  updatedAt               DateTime      @updatedAt
  updatedBy             String?
  deletedAt             DateTime?
  deletedBy             String?

  // relations
  payment        Payment   @relation(fields: [paymentId], references: [id], onDelete: Cascade)
}

/* DISPUTES */
model Dispute {
  id                    String    @id @default(uuid())
  userId                String
  paymentId             String    @unique
  serviceRequestId      String
  reason                String
  status                DisputeStatus
  createdAt             DateTime  @default(now())
  updatedAt             DateTime?
  updatedBy             String?
  deletedAt             DateTime?
  deletedBy             String?

 // relations
  payment     Payment   @relation(fields: [paymentId], references: [id], onDelete: Cascade)
}

model Subscriptions {
  // this model contains all service provider payments for fees, subscriptions, FeaturedPlans
  id                      String @id @default(uuid())
  serviceProviderId       String
  serviceId               String
  type                    PaymentType
  feesId                  String
  subscriptionplanId      String
  featuredPlanId          String
  status                  Status  // keeps track of active and inactive subscriptions. payment activates
  expiryDate              DateTime
  fees                    Fees @relation(fields: [feesId], references: [id], onDelete: Cascade)
  subscriptionplan        SubscriptionPlans @relation(fields: [subscriptionplanId], references: [id], onDelete: Cascade)
  featuredPlan            FeaturedPlans @relation(fields: [featuredPlanId], references: [id], onDelete: Cascade)
  invoice                 Invoice[]

  createdAt               DateTime  @default(now())
  updatedAt               DateTime?
  updatedBy               String?
  deletedAt               DateTime?
  deletedBy               String?         
  @@unique([serviceProviderId, feesId])
  @@unique([serviceProviderId, subscriptionplanId])
  @@unique([serviceProviderId, featuredPlanId])
  @@index([status])
  @@index([expiryDate])
}


model Fees {
  id                    String   @id @default(uuid())
  name                  FeesType
  amount                Decimal
  status                Status 
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  updatedBy             String?
  deletedAt             DateTime?
  deletedBy             String?

  subscriptions         Subscriptions[]
}

model SubscriptionPlans {
  id                    String   @id @default(uuid())
  plan                  String
  amount                Decimal
  timeFrame             Int  // number of days this subscription covers
  status                Status  
  createdAt     DateTime @default(now())
  updatedAt   DateTime @updatedAt
  updatedBy     String?
  deletedAt     DateTime?
  deletedBy     String?

  subscriptions         Subscriptions[]
}

model FeaturedPlans {
  id                    String   @id @default(uuid())
  plan                  String
  amount                Decimal
  timeFrame             Int  // number of days this subscription covers
  status                Status  
  createdAt     DateTime @default(now())
  updatedAt   DateTime @updatedAt
  updatedBy     String?
  deletedAt     DateTime?
  deletedBy     String?

  subscriptions         Subscriptions[]
}

/* ENUMS */

enum FeesType {
  KYC
  CERTIFICATION
}

enum PaymentType {
  KYC
  CERTIFICATION
  FEATUREDPLANS
  SUBSCRIPTIONPLANS
}


enum Status {
  ACTIVE
  INACTIVE
}

enum PaymentReason {
  WALLETFUNDING
  SUBSCRIPTION
  KYC
  CERTIFICATION
  FEATURED
  SERVICEREQUEST
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  DISPUTED
  REFUNDED
}

enum InvoiceStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  OVERDUE
}

enum RefundStatus {
  REQUESTED
  APPROVED
  DECLINED
  PROCESSING
}

enum DisputeStatus {
  OPEN
  RESOLVED
  REJECTED
}

enum PaymentOption {
  CASH
  CARD
  TRANSFER
}
